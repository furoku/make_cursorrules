# Cursorの`.cursor/rules`チートシート

## `.cursor/rules`とは？
**Cursorルール**は、Cursor IDE（AIコーディングアシスタント)に対する振る舞いやコーディング方針を指定できる設定ファイル群です。バージョン0.45から、プロジェクトごとのルールはプロジェクトディレクトリ直下の`.cursor/rules/`フォルダに複数ファイルで保存する方式に拡張されました（従来は単一の`.cursorrules`ファイルでしたが非推奨）。これらのルールファイルによって、AIに**プロジェクト固有のコンテキストやコーディング規約**を理解させ、回答内容をカスタマイズできます。例えば「このプロジェクトではTypeScriptを使用」「特定のコーディング規約に従う」といった指示を事前に与えることで、AIのコード提案や回答をプロジェクトに即したものにできます。

## 基本の書き方とフォーマット
**ルールファイルの拡張子**は`.mdc`（Markdown Domain Configurationの略）で、内容はMarkdown形式のテキストです。各ルールファイルは**YAMLフロントマター**（`---`で囲まれたメタデータ部分）と、その下に続く**ルール本文**から構成されます。YAMLフロントマターには少なくとも以下を記述します：

- **説明 (Description/name)**: ルールの用途や対象を簡潔に記述（UI上での識別用）
- **適用パターン (Globs)**: どのファイルパスに対してこのルールを自動適用するかのGlobパターン（ワイルドカード指定）
- **（任意）トリガー (Triggers)**: エージェントモードで自動実行する際のイベント（例: `file_change`）
- **（任意）バージョン等**: ルールのバージョン番号など（必要に応じて）

YAMLフロントマターの下に、Markdown形式で実際のルール内容（ガイドライン）を記述します。見出しやリストを用いて整理し、AIへの指示を書きます。**Bullet（箇条書き）形式**で箇条書きの規約やガイドラインを列挙したり、必要に応じて`
@file
`記法で関連ファイルを参照させることも可能です。

**🔰コード例：**以下は`.cursor/rules`内のルールファイル例です（YAMLフロントマター＋Markdown本文）：

```markdown
---
name: "Python Guidelines"
globs: ["**/*.py"]
triggers: ["file_change"]
---
# Pythonファイル向けガイドライン
- 可能な限りPython 3.10以上の新機能（パターンマッチなど）を使用する
- PEP 8に沿ったコーディングスタイルを徹底する
- 公開関数には必ずdocstringを書く

@file
 ../docs/ARCHITECTURE.md  <!-- 他ファイルの内容を参照 -->
```

上記の例では、`name`でルール名を付け、`globs`で`**/*.py`（プロジェクト内の全てのPythonファイル）に適用するよう指定しています。`triggers`に`file_change`を設定することで、このルールが（エージェントモードにおいて）ファイル変更時に適用されるイベントトリガーも定義しています。Markdown本文にはPythonコードに関するガイドラインを箇条書きで記述し、最後に`
@file
`でプロジェクトドキュメントを参照する例を示しています。

**※注意:** ルールファイルは**必ず拡張子`.mdc`**にする必要があります。また**先頭にYAMLフロントマターがないと認識されない**ため注意してください。Cursorのドキュメント上は「任意の形式のファイルを置ける」と読める箇所もありますが、実際には**YAML形式で書かれた.mdcファイルのみ**がルールとして読み込まれます。ルールファイルはCursorアプリのコマンドパレット（`Cmd/Ctrl + Shift + P`）から「New Cursor Rule」を選び作成すると、テンプレートが用意されるので初心者にはおすすめです。

## ベストプラクティス（効果的なルールの書き方）

- **ルールの一貫性**: **ルール同士が矛盾しないように**してください。例えばあるルールで「Tab文字でインデント」とし、別のルールで「スペースでインデント」と指示すると矛盾します。プロジェクト全体で統一した方針を定め、それに沿った内容のみを書くようにします。

- **多面的な指示を網羅**: コーディングスタイル、文書コメント、エラー処理、パフォーマンスなど**様々な観点**についてルール化すると効果的です。一つのルールファイル内でセクション（見出し）を分け、例えば「コードスタイル」「エラーハンドリング」「セキュリティ」「パフォーマンス最適化」といった項目ごとにガイドラインを箇条書きにすることで、AIに包括的な指針を与えられます。

- **プロジェクト固有のコンテキストを明示**: プロジェクトの目的・技術スタック・構成をAIに理解させるため、**固有の情報を盛り込む**ようにします。例えば「このプロジェクトはReact + TypeScriptベースである」「REST APIバックエンドにはFastAPIを使用している」「アーキテクチャ上の独自決定事項（例: マイクロサービス構成）を採用している」等を最初に記述すると、AIがプロジェクトの前提を把握しやすくなります。

- **柔軟性と厳格さのバランス**: AIに守らせたい重要ルールは明確に示しつつも、**創造性を阻害しない適度な余白**を残しましょう。厳しすぎるルールでがんじがらめにするとAIの提案が限定的になりすぎる可能性があります。一方で緩すぎるとプロジェクト方針に合わない回答が出る恐れがあります。**「核心となる原則は厳守させ、それ以外はある程度の裁量を認める」**ようなバランスが望ましいです。

- **具体例を示す**: 可能であれば**コードスニペットや例**をルール内に含めてください。たとえば「適切なフォルダ構成」のルールを示す際に、簡単なツリー構造の例や、「命名規則」のルールで良い例・悪い例のコード片を示すと、AIはその形式や水準を参考にします。短いコードブロックを埋め込むことで、単なる文章だけでは伝わりにくいニュアンスも共有できます。

- **ルールを用途別に分割**: すべてを一つのファイルに長々と書くのではなく、**関心事ごとにルールファイルを分ける**と効果的です。Cursor v0.45以降は複数ルールファイルを使えるため、例えば「全体共通のルール」「フロントエンド用ルール」「バックエンド用ルール」「テストコード用ルール」のようにファイルを分けます。これにより不要な部分をコンテキストに含めずに済み、AIに常に適切なルールのみを適用できます。またルール同士が独立しているため、追加・修正もしやすくなります。

- **ファイル名と適用順序の工夫**: 複数のルールファイルがある場合、**ファイル名に番号やカテゴリを付けて整理**するとよいでしょう。Cursorはルールファイル名のアルファベット順（または数字順）に読み込みを行っているため、衝突時の優先度を制御できます。あるユーザ事例では、`001-...mdc`を「コアルール」、`100-...mdc`を「統合ルール」、`200-...mdc`を「パターン別ルール」とし、三桁の番号でグルーピングしています。例: `001-Core-Security.mdc`（基本セキュリティ方針）、`100-API-Integration.mdc`（API統合関連）、`210-Data-Validation.mdc`（データ検証パターン）といった具合です。これにより、ルールの適用順序を意図的にコントロールし、**重要なルールが他に上書きされないよう**にできます。

- **定期的な見直しと更新**: プロジェクトの進行に合わせて**ルールをアップデート**しましょう。新しい技術を導入した際やコード規約を変更した際には、それを反映するようにルールを追加・修正します。古くなった指示（例えば「古いライブラリXを使用」等）は誤った提案につながるため、定期的にルールファイルをチェックし最新の状態に保つことが大切です。

## よくあるミスとその回避策

- **形式ミス（読み込まれないルール）**: `.mdc`ファイルとして正しく保存されていなかったり、YAMLフロントマターの書式が崩れているとルールが**適用されません**。例えば拡張子が`.md`のままだったり、`---`の開始・終了を忘れるミスがよくあります。**対策:** CursorアプリのUI経由でルールを作成すれば書式ミスを防げますし、自作する場合も雛形を参考にしてYAMLを書き漏れなく記述しましょう。また、YAML内でインデントやコロン(`:`)の位置が誤ると無視される可能性があるため、フォーマットには注意が必要です。

- **矛盾・競合するルール**: 複数ファイルのルールが**相反する指示**を含む場合、AIがどちらに従うか不明瞭になります。一般的に**後から適用されたルールが優先**される傾向があります（最後に読み込まれたルールが勝つ）。例えばグローバルルールで「回答は日本語」とし、プロジェクトルールで「回答は英語」と書いた場合、競合してしまいます。**対策:** 矛盾を起こさないよう内容を精査するか、どうしても必要な場合は意図的に優先度付け（上記の命名規則など）を行います。また、**グローバル設定のルール**（全プロジェクト共通）と**プロジェクト個別ルール**で食い違いがあると挙動が不安定になるため、どちらかに一本化するか、プロジェクトルール内で「グローバル設定を上書きする」旨を明記するとよいでしょう。

- **Globパターンの漏れ・誤り**: `globs`で指定したパターンに誤りがあると、**意図したファイルにルールが適用されません**。例えば全体に適用したいのに`*`ではなく`*.js`と書いてしまう、あるいはサブディレクトリに適用したいのに`**`を付け忘れる、といったミスです。**対策:** パターンはシンプルすぎず広すぎず慎重に指定します（詳細は後述のテクニック参照）。全ファイルに適用したい場合はワイルドカード`*`や`**/*`を使い、特定ディレクトリ以下なら`dir/**/*`を使います。ルール追加後は、実際に対象ファイルをAIに質問してルールが効いているか確認しましょう。

- **ルール内容の過剰な長文化**: ルールにあれもこれもと**情報を詰め込みすぎる**のも良くありません。AIのコンテキストウィンドウには上限があるため、極端に長いルールは一部無視されたり、逆に回答生成に悪影響を及ぼす可能性があります。特に旧方式の`.cursorrules`単一ファイルではサイズ制限なく書けますが、長すぎるとAIが段落ごとスキップすることも報告されています。**対策:** ルールはポイントを絞って**簡潔に**書きましょう。どうしても詳細な説明が必要な場合は、後述する`
@file
`で外部の詳細ドキュメントを参照させ、ルールファイル自体は概要や指針のみに留める方が効果的です。

- **ルールへの過信**: CursorルールはAIの出力を「ある程度**誘導**する」ものですが、**完全に強制するものではない**点に留意しましょう。ルールでガイドラインを示しても、AIは最終的にはプロンプト全体から文脈を判断して回答を生成します。したがって、ルールを設定したからといって全て安心せず、**AIの提案内容を人間がレビューする体制**は依然必要です。特にクリティカルな制約（「絶対に○○してはいけない」等）は、ルールと併せてAIへの質問内容でも再度念押しするなど二重に確認すると安全です。

- **保存や同期の不具合**: 現在のCursorでは、.mdcファイルの編集内容が**正しく保存されない不具合**が報告されています。編集中に内容が消えてしまったり、意図したとおりに反映されないケースがあります。**対策:** 問題が発生した場合、一度**Cursorアプリを完全に再起動**し、終了時に表示される「未保存の変更を検出」ダイアログで「Override（上書き保存）」を選択してから再度開き直す方法が有効との報告があります。煩わしいですが、重要なルール編集時には適宜この手順を踏んで確実に保存されているか確認してください。また、ルールファイルも通常のコード同様にGitなどで**バージョン管理**しておくと、万一消えても履歴から復元できます。

## 便利なテクニック・高度な設定

- **ルールの継承（チェイン）**: **他のルールファイルを再利用**したい場合、`
@file
`構文で別の.mdcファイルをインクルードできます。例えば共通の基本ルールを`base.mdc`に書いておき、各個別ルールファイルの冒頭で`
@base
.mdc`と記述すると、その内容が自動的に含まれます。これにより重複記載を避け、**ルールのDRY化**（Don't Repeat Yourself）を図れます。実際、CSSの継承のように**ベースとなるルールを作り、それを各所で参照する**ことで一貫性と保守性が向上します。

- **Globパターンの高度な指定**: `globs`では配列で**複数のパターン**を指定できます。さらに先頭に`!`を付けることで**除外パターン**も設定可能です。例えば:
```yaml
globs:
- "app/models/**/*.rb"
- "app/services/**/*.rb"
- "!app/models/legacy/**/*.rb" # 特定ディレクトリを除外
```
この例では、`app/models`と`app/services`以下の全ての.rbファイルに適用しつつ、`app/models/legacy`以下は除外しています。このように広すぎるパターンには除外条件を加える、あるいはファイル種別やディレクトリ単位で**きめ細かくルールを分割**することで、必要な場面にのみルールを適用できます。

- **エージェントモードとトリガー**: Cursorのエージェントモードを活用すると、ルールに**自動的な手順実行**を組み込めます。例えば、`triggers: ["file_change"]`としたルールに、ファイル変更時に実行すべき処理（テストの実行やフォーマッタ適用など）を記述すれば、エージェントがそれを検知して動作します。さらに**「Agent Behavior」**のセクションをルール内に設け、「AIが取るべき行動手順」を箇条書きすることで、自律的にコード修正やプランニングをさせることも可能です。例えばルール本文に「1. docsフォルダの`http://Roadmap.md`をまず読む」「2. コーディング前に短いプランを書く」「3. テストを全て実行しパスするまでプッシュ禁止」等と書けば、エージェントはそれに沿った行動を取ろうとします。このようにCursorルールは**受動的な指示書から、能動的にAIの動作を制御するスクリプト**へと進化しつつあります。

- **プロジェクト資料やコードの参照**: ルール内で`
@file
 <パス>`と書くことで、**そのファイルの内容をAIに追加コンテキストとして与える**ことができます。これは非常に強力な機能で、たとえば「`
@file
 ../README.md`」と書けばプロジェクトのREADMEを、`
@file
 ../docs/api_spec.md`と書けばAPI仕様書を、AIが回答を生成する際に参照する材料として読み込ませることができます。大量の説明をルール内に書く代わりに、詳細は別ファイルに任せて参照させることで、ルールファイル自体は簡潔に保ちつつAIに豊富な知識を与えられます。ドキュメント以外にも設定ファイルやスキーマ (`
@file
 ../schema.prisma` など) を参照させれば、AIはプロジェクトの内部構造や定義を理解した上で回答できるようになります。

- **AIへのロール指示と出力フォーマット**: ルールを使って**AIのロール（人格や役割）**を設定したり、**回答のフォーマット**を強制することもできます。例えばルール冒頭に「`あなたは熟練のRails開発者です`」と書けば、AIがその専門家になりきって回答する効果があります。また、回答を特定のテンプレートに沿わせたい場合、ルール内で期待するフォーマット例を示すことも有効です（例えば「回答は＜結論＞と＜詳細＞の2つのセクションに分けて書くこと」など）。実際、グローバルルールでXML風タグを用いた回答フォーマット指定を行い、AIに推論過程と最終解を分けて書かせる高度な例もあります。このようなカスタムフォーマットを用いる場合は、AIが誤解しないようフォーマット例を明示し、必要に応じて誤った形式の場合の修正指示も含めるとよいでしょう。

- **ルールファイルの整理術**: プロジェクトが大きくなるとルールファイルも増えるため、**フォルダ構成で体系的に整理**するのがおすすめです。`.cursor/rules/`ディレクトリ以下にサブフォルダを作り、ドメインやレイヤーごとに分けます。例:
```
.cursor/rules/
├── 001-general.mdc         # 全体共通ルール
├── frontend/              # フロントエンド関連
│   ├── 100-react.mdc       # React向けルール
│   └── 110-css.mdc         # CSS/スタイルガイド
├── backend/               # バックエンド関連
│   ├── 200-database.mdc    # データベースに関するルール
│   └── 210-api.mdc         # API設計に関するルール
└── docs/                  # ドキュメント関連ルール
└── 300-writing.mdc     # ドキュメント執筆スタイル
```
このようにディレクトリで区切ることで、視認性が上がり管理もしやすくなります。また、チーム内で誰かがルールを編集する際も、該当分野のフォルダだけ見れば良いのでスムーズです。ルールファイル自体もGit管理下に置かれるため、Pull Requestでレビューしたりコメントを付けたりといった運用も可能です。

## 具体的なユースケース（活用事例）

- **コーディング規約の自動適用**: チームで決めたコーディングスタイルや命名規則、LintルールなどをCursorルールに落とし込むことで、AIが提案するコードも自動的に規約に沿ったものになります。例えば「インデントはスペース2つ」「変数名はキャメルケース、クラス名はパスカルケース」「Reactでは関数コンポーネントとフックを使い、クラスコンポーネントは使わない」等をルール化しておけば、スタイル統一とレビュー工数削減に役立ちます。

- **プロジェクト技術スタックに合わせた支援**: プロジェクトが複数の言語・フレームワークで構成されている場合、各スタックに合わせたルールを用意できます。例えばフロントエンド（TypeScript/React用）、バックエンド（Python/FastAPI用）、インフラ（TerraformやDocker用）など**ファイル種別ごとに異なるガイドライン**を用意し、対応する拡張子に適用します。これにより、AIは開いているファイルに応じて適切なルールを読み込み、文脈に合った回答をしてくれます（Reactのファイルを編集中はReact向けルールが、Pythonコード中ではPython向けルールが使われる、など）。

- **ドキュメント駆動の開発サポート**: プロジェクトの設計書や仕様書をルールに組み込むことで、AIは**公式ドキュメントに沿った回答**を返しやすくなります。例えば「このプロジェクトではDDD(ドメイン駆動設計)を採用している」旨や「アーキテクチャはdocs/architecture.mdに記載」とルールに書き、さらに`
@file
`で該当ドキュメントを参照させておけば、AIは設計方針を踏まえた助言をしてくれます。また、新機能の要求仕様（PRD）やワークフロー図なども組み込めば、仕様漏れのない提案や実装手順をAIから引き出すのに役立ちます。

- **自動化エージェントとしての利用**: Cursorのエージェントモードとルールを組み合わせると、**開発プロセスの一部を自動化**できます。例えば「コード変更後に自動でテストを実行し、失敗したら修正提案させる」エージェントをルールで定義したり、「リポジトリ内の全Markdownファイルのリンク切れをチェックする」といったタスクをエージェントに行わせることも可能です。実現にはルール内で手順を指示し（前述のAgent Behaviorセクションなど）、必要に応じて`triggers`でイベントを設定します。こうした仕組みは簡易CIのように働き、開発者の手を離れてもAIが一定の品質担保作業を行ってくれるという利点があります。

- **プロジェクト固有のバグ回避**: 過去に踏んだ地雷や、このプロジェクトでは使ってはいけない機能などを**明文化しておく**と、AIが同じミスを繰り返さなくなります。例えば「ライブラリXのバージョンYにはメモリリークのバグがあるため使用禁止」「DeprecatedなAPIであるZは使わず代替APIを使うこと」といったルールです。AIは提案時にそれらを考慮し、不適切な方策を避けるようになります。人間の新人メンバーにも共有したい**プロジェクトの暗黙知**をルール化しておくことで、コードレビュー前にAIの段階で潰せる問題が増えるでしょう。

- **新人エンジニアのオンボーディング**: 新しくプロジェクトに参加した人がコードを書き始める際も、Cursorルールがあれば安心です。プロジェクト特有のコーディング規約やフォルダ構成、使用するツール類がルールに網羅されていれば、AIがそれを踏まえてコード支援してくれるため、**新人でもプロジェクトの流儀に沿ったコードを書きやすくなります**。これはチーム全体の生産性向上にも繋がります。例えば「このプロジェクトではPull Requestのテンプレートに沿って説明を書く必要がある」など開発フロー面の決まりもルールに書いておけば、AIがプルリク説明文作成を手助けしてくれるかもしれません。

---

**まとめ:** Cursorの`.cursor/rules`を活用すれば、AIにプロジェクト専用の「知識」と「規律」を持たせることができます。基本フォーマットに従って適切にルールを記述し、ベストプラクティスに沿って内容を磨けば、AIはまるでプロジェクトメンバーの一人のように状況を理解した回答やコード提案を行ってくれるでしょう。定期的にルールを見直しつつ、Cursorルールを**チームのコーディング規約や開発ドキュメントと一体化**させて運用することで、より統一感のある生産的な開発体験を得られるはずです。ぜひあなたのプロジェクトにも合わせたCursorルールを作成して、AIアシスタントを育ててみてください。🚀